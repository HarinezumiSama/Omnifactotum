<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ include file="..\Omnifactotum\AsyncFactotum.Common.ttinclude" #>
<#@ output encoding="utf-8" extension=".Generated.cs" #>
// <auto-generated>
//     This code was generated by T4 template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System;
using System.Threading.Tasks;
using NUnit.Framework;

namespace Omnifactotum.Tests
{
    [TestFixture]
    internal sealed class AsyncFactotumTests
    {
        private static readonly TimeSpan TaskWaitTime = TimeSpan.FromSeconds(1);

        //// ComputeAsync

        #region Tests: ComputeAsync: Exception and message error logging: Positive

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestComputeAsyncWith<#= index #>ArgAndExceptionAndMessageErrorLoggingWhenValidArgumentsAndUnderlyingMethodSucceedsThenSucceeds()
        {
            var errorLogged = false;
            var task = AsyncFactotum.ComputeAsync(Compute<#= index #>, (Exception exception, string message) => errorLogged = true<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>);
            AssertTaskFinishesFast(task);

            Assert.That(task.Exception, Is.Null);
            Assert.That(task.Result, Is.EqualTo(<#= -index #>));
            Assert.That(errorLogged, Is.False);
        }

<# } #>
        #endregion

        #region Tests: ComputeAsync: Exception and message error logging: Negative

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestComputeAsyncWith<#= index #>ArgAndExceptionAndMessageErrorLoggingWhenInvalidArgumentsThenThrows()
        {
            Assert.That(
                () => AsyncFactotum.ComputeAsync<<#= EnumeratePrefixedValues("int", ", ", false, index, true) #>int>(null, (Exception exception, string message) => { }<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);

            Assert.That(
                () => AsyncFactotum.ComputeAsync(Compute<#= index #>, (AsyncFactotum.LogErrorWithExceptionAndMessage)null<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);
        }

<# } #>
        #endregion

        #region Tests: ComputeAsync: Exception error logging: Positive

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestComputeAsyncWith<#= index #>ArgAndExceptionErrorLoggingWhenValidArgumentsAndUnderlyingMethodSucceedsThenSucceeds()
        {
            var errorLogged = false;
            var task = AsyncFactotum.ComputeAsync(Compute<#= index #>, (Exception exception) => errorLogged = true<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>);
            AssertTaskFinishesFast(task);

            Assert.That(task.Exception, Is.Null);
            Assert.That(task.Result, Is.EqualTo(<#= -index #>));
            Assert.That(errorLogged, Is.False);
        }

<# } #>
        #endregion

        #region Tests: ComputeAsync: Exception error logging: Negative

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestComputeAsyncWith<#= index #>ArgAndExceptionErrorLoggingWhenInvalidArgumentsThenThrows()
        {
            Assert.That(
                () => AsyncFactotum.ComputeAsync<<#= EnumeratePrefixedValues("int", ", ", false, index, true) #>int>(null, (Exception exception) => { }<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);

            Assert.That(
                () => AsyncFactotum.ComputeAsync(Compute<#= index #>, (AsyncFactotum.LogErrorWithException)null<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);
        }

<# } #>
        #endregion

        #region Tests: ComputeAsync: Message error logging: Positive

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestComputeAsyncWith<#= index #>ArgAndMessageErrorLoggingWhenValidArgumentsAndUnderlyingMethodSucceedsThenSucceeds()
        {
            var errorLogged = false;
            var task = AsyncFactotum.ComputeAsync(Compute<#= index #>, (string message) => errorLogged = true<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>);
            AssertTaskFinishesFast(task);

            Assert.That(task.Exception, Is.Null);
            Assert.That(task.Result, Is.EqualTo(<#= -index #>));
            Assert.That(errorLogged, Is.False);
        }

<# } #>
        #endregion

        #region Tests: ComputeAsync: Message error logging: Negative

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestComputeAsyncWith<#= index #>ArgAndMessageErrorLoggingWhenInvalidArgumentsThenThrows()
        {
            Assert.That(
                () => AsyncFactotum.ComputeAsync<<#= EnumeratePrefixedValues("int", ", ", false, index, true) #>int>(null, (string message) => { }<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);

            Assert.That(
                () => AsyncFactotum.ComputeAsync(Compute<#= index #>, (AsyncFactotum.LogErrorWithMessage)null<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);
        }

<# } #>
        #endregion

        #region Tests: ComputeAsync: Default error logging: Positive

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestComputeAsyncWith<#= index #>ArgAndDefaultErrorLoggingWhenValidArgumentsAndUnderlyingMethodSucceedsThenSucceeds()
        {
            var task = AsyncFactotum.ComputeAsync(Compute<#= index #><#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>);
            AssertTaskFinishesFast(task);

            Assert.That(task.Exception, Is.Null);
            Assert.That(task.Result, Is.EqualTo(<#= -index #>));
        }

<# } #>
        #endregion

        #region Tests: ComputeAsync: Default error logging: Negative

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestComputeAsyncWith<#= index #>ArgAndDefaultErrorLoggingWhenInvalidArgumentsThenThrows()
        {
            Assert.That(
                () => AsyncFactotum.ComputeAsync<<#= EnumeratePrefixedValues("int", ", ", false, index, true) #>int>(null<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);
        }

<# } #>
        #endregion

        //// ExecuteAsync

        #region Tests: ExecuteAsync: Exception and message error logging: Positive

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestExecuteAsyncWith<#= index #>ArgAndExceptionAndMessageErrorLoggingWhenValidArgumentsAndUnderlyingMethodSucceedsThenSucceeds()
        {
            var errorLogged = false;
            var task = AsyncFactotum.ExecuteAsync(Execute<#= index #>, (Exception exception, string message) => errorLogged = true<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>);
            AssertTaskFinishesFast(task);

            Assert.That(task.Exception, Is.Null);
            Assert.That(errorLogged, Is.False);
        }

<# } #>
        #endregion

        #region Tests: ExecuteAsync: Exception and message error logging: Negative

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestExecuteAsyncWith<#= index #>ArgAndExceptionAndMessageErrorLoggingWhenInvalidArgumentsThenThrows()
        {
            Assert.That(
                () => AsyncFactotum.ExecuteAsync<#= EnumerateTypeArgs("int", index) #>(null, (Exception exception, string message) => { }<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);

            Assert.That(
                () => AsyncFactotum.ExecuteAsync(Execute<#= index #>, (AsyncFactotum.LogErrorWithExceptionAndMessage)null<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);
        }

<# } #>
        #endregion

        #region Tests: ExecuteAsync: Exception error logging: Positive

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestExecuteAsyncWith<#= index #>ArgAndExceptionErrorLoggingWhenValidArgumentsAndUnderlyingMethodSucceedsThenSucceeds()
        {
            var errorLogged = false;
            var task = AsyncFactotum.ExecuteAsync(Execute<#= index #>, (Exception exception) => errorLogged = true<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>);
            AssertTaskFinishesFast(task);

            Assert.That(task.Exception, Is.Null);
            Assert.That(errorLogged, Is.False);
        }

<# } #>
        #endregion

        #region Tests: ExecuteAsync: Exception error logging: Negative

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestExecuteAsyncWith<#= index #>ArgAndExceptionErrorLoggingWhenInvalidArgumentsThenThrows()
        {
            Assert.That(
                () => AsyncFactotum.ExecuteAsync<#= EnumerateTypeArgs("int", index) #>(null, (Exception exception) => { }<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);

            Assert.That(
                () => AsyncFactotum.ExecuteAsync(Execute<#= index #>, (AsyncFactotum.LogErrorWithException)null<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);
        }

<# } #>
        #endregion

        #region Tests: ExecuteAsync: Message error logging: Positive

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestExecuteAsyncWith<#= index #>ArgAndMessageErrorLoggingWhenValidArgumentsAndUnderlyingMethodSucceedsThenSucceeds()
        {
            var errorLogged = false;
            var task = AsyncFactotum.ExecuteAsync(Execute<#= index #>, (string message) => errorLogged = true<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>);
            AssertTaskFinishesFast(task);

            Assert.That(task.Exception, Is.Null);
            Assert.That(errorLogged, Is.False);
        }

<# } #>
        #endregion

        #region Tests: ExecuteAsync: Message error logging: Negative

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestExecuteAsyncWith<#= index #>ArgAndMessageErrorLoggingWhenInvalidArgumentsThenThrows()
        {
            Assert.That(
                () => AsyncFactotum.ExecuteAsync<#= EnumerateTypeArgs("int", index) #>(null, (string message) => { }<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);

            Assert.That(
                () => AsyncFactotum.ExecuteAsync(Execute<#= index #>, (AsyncFactotum.LogErrorWithMessage)null<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);
        }

<# } #>
        #endregion

        #region Tests: ExecuteAsync: Default error logging: Positive

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestExecuteAsyncWith<#= index #>ArgAndDefaultErrorLoggingWhenValidArgumentsAndUnderlyingMethodSucceedsThenSucceeds()
        {
            var task = AsyncFactotum.ExecuteAsync(Execute<#= index #><#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>);
            AssertTaskFinishesFast(task);

            Assert.That(task.Exception, Is.Null);
        }

<# } #>
        #endregion

        #region Tests: ExecuteAsync: Default error logging: Negative

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        [Test]
        public void TestExecuteAsyncWith<#= index #>ArgAndDefaultErrorLoggingWhenInvalidArgumentsThenThrows()
        {
            Assert.That(
                () => AsyncFactotum.ExecuteAsync<#= EnumerateTypeArgs("int", index) #>(null<#= EnumeratePrefixedValues("{0}", ", ", true, index, false) #>),
                Throws.ArgumentNullException);
        }

<# } #>
        #endregion

        #region Private Methods

        private static void AssertTaskFinishesFast(Task task)
        {
            if (!task.Wait(TaskWaitTime))
            {
                Assert.Fail(@"The task is supposed to get completed pretty much immediately.");
            }
        }

        #endregion

        #region Private Methods: Callee: Compute

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        private static int Compute<#= index #>(<#= EnumeratePrefixedValues("int arg{0}", ", ", false, index, false) #>)
        {
<# if (index > 0) { #>
            <#= EnumeratePrefixedValues(@"Assert.That(arg{0}, Is.EqualTo({0}));", Environment.NewLine + new string(' ', 12), false, index, false) #>

            Assert.That(new[] { <#= EnumeratePrefixedValues("arg{0}", ", ", false, index, false) #> }, Is.Unique);

<# } #>
            return <#= -index #>;
        }

<# } #>
        #endregion

        #region Private Methods: Callee: Execute

<# for (var index = 0; index <= MaxParameterCount; index++) { #>
        private static void Execute<#= index #>(<#= EnumeratePrefixedValues("int arg{0}", ", ", false, index, false) #>)
        {
<# if (index > 0) { #>
            <#= EnumeratePrefixedValues(@"Assert.That(arg{0}, Is.EqualTo({0}));", Environment.NewLine + new string(' ', 12), false, index, false) #>

            Assert.That(new[] { <#= EnumeratePrefixedValues("arg{0}", ", ", false, index, false) #> }, Is.Unique);
<# } #>
        }

<# } #>
        #endregion
    }
}